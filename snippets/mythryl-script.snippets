# shebang
snippet #!
	#!/usr/bin/env mythryl
	
# TRUE
snippet T
	TRUE
# FALSE
snippet F
	FALSE
# stipulate-herein-end
snippet stipulate
	stipulate
	    ${1:/* stipulation code */}
	herein
	    ${2:/* code */}
	end;
# Ternary conditional
snippet t
	${1:/* condition */}   ??   ${2:a}   ::   ${3:b};
# where-end
snippet wh
	where
	    ${1:/* where is your stuff? */};
	end;
# for (;;) { ... }
snippet f;;
	for (${1:{;;}) {
	    ${2:/* code */}
	};
# for ( ) { ... }
snippet while
	for (${1:/* halt condition */}) {
	    ${1:/* code */}
	};
# for (i=0, i<limit; ++i) { ... }
snippet for
	for (${2:i} = 0; $2 < ${1:count}; ${3:++}$2) {
	    ${4:/* code */}
	};
# if-fi
snippet if
	if   (${1:FALSE})
	     ${2:/* code */};
	${3:else}
	     ${4}
	fi;
# elif
snippet elif
	elif ${1:/* condition */}
	     ${2:/* code */};
# case-esac
snippet case
	case ${1:/* expression */}

	     ${2:/* pattern */}
	     =>
	     ${3:/* code */};

	     _
	     =>
	     ${4:/* code */};
	esac;
# fn-end
snippet fn
	fn  ${1:/* pattern */}
	    =>
	    ${2:/* code */};
	end${3:;}
# fun-end
snippet fun
	fun ${1:/* fun! */}
	    ${2:/* pattern */}
	    =>
	    ${3:/* code */};
	end;
# package
snippet package
	package ${1:package_name} :
	    ${4:(weak)}
	    ${2:ApiName}
	{
	    ${3:/* package definition */}
	};
# TODO generic package
snippet generic
	generic package ${1:generic_package_name}
	    (
	      package ${2:package_name1}: ${3:Api_Name1};
	      # package package_name2: Api_Name2;
	    )
	:
	    ${4:(weak)}
	${5:Api_Name}
	=
	package {
	    package $2 = $2;
	    ${6:/* package definition */}
	};
# api
snippet	api
	api ${1:ApiName} {
		${2:/* api declaration */}
	};
# main
snippet main
	package main: api {
	    main: ( String, List(String) ) -> winix::process::Status;
	    }
	{
	    ${1:/* code */}
	    fun main (name, args: List String) = {
		${2:/* main code */}
		winix::process::success;
	    };
	};
# regexp matching
snippet =~
	=~ ./${1:regularexpression}/
snippet ~
	=~ ./${1:regularexpression}/
# scripting
snippet x
	exit ${1:0};
snippet X
	exit ${1:1};
# string newline continuation
# NOTE: it seems to only match \<\\\>
snippet \
	\
	\
